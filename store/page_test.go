package store

import (
	"bytes"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestPage_ReadFrom(t *testing.T) {
	t.Run("empty", func(t *testing.T) {
		assert := assert.New(t)

		r := bytes.NewReader([]byte{})

		p := NewPage(128, 16)
		_, err := p.ReadFrom(r)
		assert.Error(err)
	})

	t.Run("blank", func(t *testing.T) {
		assert := assert.New(t)

		r := bytes.NewReader([]byte{
			0x01, 0x00, 0x00, 0x00, // page type: branch, page cell count: 0
			0x00, 0x00, 0x00, 0x00, // page next: 0
			0x00, 0x00, 0x00, 0x00, // page prev: 0
			0x00, 0x00, 0x00, 0x00, // page left: 0

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
		})

		p := NewPage(128, 16)

		n, err := p.ReadFrom(r)
		assert.NoError(err)
		assert.Equal(int64(128), n)

		assert.Equal(branch, p.pageType)
		assert.Equal(pageNo(0), p.left)
		assert.Len(p.cells, 0)
	})

	t.Run("single cell", func(t *testing.T) {
		assert := assert.New(t)

		r := bytes.NewReader([]byte{
			0x01, 0x00, 0x00, 0x01, // page type: branch, page cell count: 1
			0x00, 0x00, 0x00, 0x00, // page next: 0
			0x00, 0x00, 0x00, 0x00, // page prev: 0
			0x00, 0x00, 0x00, 0x00, // page left: 0

			0x00, 0x00, 0x00, 0x00, // cell overflow: 0
			0x00, 0x00, 0x00, 0x01, // cell payload size: 1
			0xa0, 0x00, 0x00, 0x00, // cell payload: {}
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
		})

		p := NewPage(128, 32)

		n, err := p.ReadFrom(r)
		assert.NoError(err)
		assert.Equal(int64(128), n)

		assert.Equal(branch, p.pageType)
		assert.Equal(pageNo(0), p.left)
		assert.Len(p.cells, 1)
		assert.Equal(pageNo(0), p.cells[0].overflow)
	})

	t.Run("multiple cells", func(t *testing.T) {
		assert := assert.New(t)

		r := bytes.NewReader([]byte{
			0x01, 0x00, 0x00, 0x03, // page type: branch, page cell count: 3
			0x00, 0x00, 0x00, 0x00, // page next: 0
			0x00, 0x00, 0x00, 0x00, // page prev: 0
			0x00, 0x00, 0x00, 0x00, // page left: 0

			0x00, 0x00, 0x00, 0x00, // cell overflow: 0
			0x00, 0x00, 0x00, 0x01, // cell payload size: 1
			0xa0, 0x00, 0x00, 0x00, // cell payload: {}
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00, // cell overflow: 0
			0x00, 0x00, 0x00, 0x01, // cell payload size: 1
			0xa0, 0x00, 0x00, 0x00, // cell payload: {}
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00, // cell overflow: 0
			0x00, 0x00, 0x00, 0x01, // cell payload size: 1
			0xa0, 0x00, 0x00, 0x00, // cell payload: {}
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
		})

		p := NewPage(128, 32)

		n, err := p.ReadFrom(r)
		assert.NoError(err)
		assert.Equal(int64(128), n)

		assert.Equal(branch, p.pageType)
		assert.Equal(pageNo(0), p.left)
		assert.Len(p.cells, 3)
	})
}

func TestPage_WriteTo(t *testing.T) {
	t.Run("blank", func(t *testing.T) {
		assert := assert.New(t)

		p := NewPage(32, 16)
		p.pageType = branch

		var w bytes.Buffer
		n, err := p.WriteTo(&w)
		assert.NoError(err)
		assert.Equal(int64(32), n)

		assert.Equal([]byte{
			0x01, 0x00, 0x00, 0x00, // page type: branch, page cell count: 0
			0x00, 0x00, 0x00, 0x00, // page next: 0
			0x00, 0x00, 0x00, 0x00, // page prev: 0
			0x00, 0x00, 0x00, 0x00, // page left: 0

			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00,
		}, w.Bytes())
	})

	t.Run("single cell", func(t *testing.T) {
		assert := assert.New(t)

		p := NewPage(32, 16)
		p.pageType = branch
		p.cells = []cell{
			{size: 16},
		}

		var w bytes.Buffer
		n, err := p.WriteTo(&w)
		assert.NoError(err)
		assert.Equal(int64(32), n)

		assert.Equal([]byte{
			0x01, 0x00, 0x00, 0x01, // page type: branch, page cell count: 1
			0x00, 0x00, 0x00, 0x00, // page next: 0
			0x00, 0x00, 0x00, 0x00, // page prev: 0
			0x00, 0x00, 0x00, 0x00, // page left: 0

			0x00, 0x00, 0x00, 0x00, // cell overflow: 0
			0x00, 0x00, 0x00, 0x01, // cell payload size: 1
			0xa0, 0x00, 0x00, 0x00, // cell payload: {}
			0x00, 0x00, 0x00, 0x00,
		}, w.Bytes())
	})
}

func TestPage_Insert(t *testing.T) {
	assert := assert.New(t)

	p := NewPage(128, 32)

	c1 := cell{
		Payload: Payload{
			Key:   values{1},
			Value: values{"a"},
		},
	}
	c2 := cell{
		Payload: Payload{
			Key:   values{2},
			Value: values{"b"},
		},
	}
	c3 := cell{
		Payload: Payload{
			Key:   values{3},
			Value: values{"c"},
		},
	}

	assert.NoError(p.Insert(&c1))
	assert.Len(p.cells, 1)
	assert.Equal(c1, p.cells[0])

	assert.NoError(p.Insert(&c3))
	assert.Len(p.cells, 2)
	assert.Equal(c1, p.cells[0])
	assert.Equal(c3, p.cells[1])

	assert.NoError(p.Insert(&c2))
	assert.Len(p.cells, 3)
	assert.Equal(c1, p.cells[0])
	assert.Equal(c2, p.cells[1])
	assert.Equal(c3, p.cells[2])
}
